---
title: "Python to R: Dataframes"
author: Nischal Shrestha
output: 
  learnr::tutorial:
    fig_caption: no
    progressive: yes
    allow_skip: true
    toc: true
    toc_depth: 2
    toc_float: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
# first, some packages for interactive tutorial, polyglot environment and tidyverse
library(learnr)
library(gradethis)
library(reticulate)
library(tidyverse)
library(rlang)
library(knitr)
# code checking
tutorial_options(exercise.timelimit = 60, exercise.checker = gradethis::grade_learnr)
opts_chunk$set(echo = FALSE)
opts_chunk$set(comment = NA)
```

## Introduction

In this (very) short guide, we're going to cover some key concepts in R by relating it to the language you are comfortable with, Python. Think of this as an interactive tutorial document, where we are going to make use of a lot of "learning by doing" and letting you execute and play with code to reinforce the concepts. We shall use the **mtcars** dataset available in R throughout the tutorial.

## How do I inspect data?

### Print first few rows {.tabset .tabset-fade}

Let's go over how to inspect a dataframe:

```{r}
head(mtcars) %>% kable
```

#### In Python

```{python include = F}
# set a python variable to point to mtcars
mtcars = r.mtcars
```

You are used to printing the first few rows using `head()`

```{python echo = TRUE, eval = FALSE}
mtcars.head()
```

```{python py-head}
print(mtcars.head())
```

#### In R

An equivalent function `head()` exists. Try printing 6 rows of **mtcars** with R:

```{r head, exercise = TRUE, exercise.lines = 1}

```

```{r head-hint}
"Python calls a method on the dataframe object, whereas R passes the dataframe object to the function"
```

```{r head-check, include = FALSE}
grade_result(
  pass_if(~ identical(.result, head(mtcars)), "Great job!")
)
# grade_code("Great job!")
```


### Print last few rows {.tabset .tabset-fade}

#### In Python

You are used to printing the last few rows using `tail()`. 

```{python echo = TRUE, eval = FALSE}
mtcars.tail()
```

```{python py-tail}
print(mtcars.tail())
```

#### In R

An equivalent `tail()` function exists in R. Try print the last few rows of **mtcars** in R:

```{r tail, exercise=TRUE, exercise.lines = 1, message=FALSE}

```

```{r tail-check, include = FALSE}
grade_result(
  pass_if(~ identical(.result, tail(mtcars)), "Great job!")
)
```

## How do I index rows and columns?

### Index columns {.tabset .tabset-fade}

#### In Python

You indexed a column using either `[` or dot notation.

Both `mtcars['mpg']` and `mtcars.mpg` references the **mpg** column.

```{python eval=FALSE}
mtcars['mpg']
```

```{python py-column-indexing-2}
print(mtcars['mpg'])
```

#### In R
You can use the `[` as well. Try it out now by referencing the **mpg** column:

```{r column, exercise = TRUE, exercise.lines = 1}

```

```{r column-hint}
mtcars[col_name]
```

```{r column-check}
grade_result(
  pass_if(~ identical(.result, mtcars['mpg']), "Easy enough!"),
  fail_if(~ identical(.result, mtcars$mpg), "Using $ is fine but doesn't return a dataframe as explained in the next exercise.")
)
```


But, what happens if you use the `.` notation to reference a column? Try that now in R:

```{r column-indexing-2-wrong,  exercise = TRUE, exercise.lines = 1}

```

Since `.` can be included in a variable name, R thinks you are trying to refer to a variable. The `.` cannot be used to reference a column as you would expect coming from Python.

Instead use `$`:
```{r column-indexing-2,  exercise = TRUE, exercise.lines = 1}

```

```{r column-indexing-2-check, include = FALSE}
grade_result(
  pass_if(~ identical(.result, mtcars$mpg), "Use $ when you need to reference a column.")
)
```

### Index element {.tabset .tabset-fade}

Here's how we would access single elements.

#### In Python

You use `[` on the dataframe to reference the **mpg** column then `[` again to access the fifth item:

```{python echo = TRUE, eval = FALSE}
mtcars['mpg'][4]
``` 

```{python py-single}
print(mtcars['mpg'][4])
```

**Note** how Python is 0-indexed.

#### In R
We instead use `$` and switch to 1-indexing. Try it out!

```{r single, exercise = TRUE, exercise.lines = 1}

```

```{r single-check, include = FALSE}
grade_result(
  pass_if(~ identical(.result, mtcars$mpg[5]), "Pretty easy right?")
)
```

You may wonder why we didn't use the `[` syntax instead. Using `[` returns a dataframe, so accessing the fifth element will throw an error because you have only one column **mpg** returned. See for yourself!

```{r single-check-wrong, exercise = TRUE, exercise.lines = 1, exercise.eval = TRUE}

```

## How do I filter data?

### Filter with conditions {.tabset .tabset-fade}

Suppose we want to filter mtcars such that we only look at 6 or more **cyl** (cylinders).

#### In Python

Filtering dataframes can be achieved by placing a boolean expression in a subset expression using `[` 

```{python echo = TRUE, eval = FALSE}
mtcars[mtcars.cyl > 4]
``` 

```{python py-filter}
print(mtcars.cyl[mtcars.cyl > 4])
```

#### In R

Try the same expression except using `$` to reference a column and observe what happens:
```{r filter-wrong, exercise = TRUE, exercise.eval = TRUE, exercise.lines = 1}

```

```{r filter-wrong-hint, include = FALSE}
mtcars[mtcars$col_name > 4]
```

The problem here is that R subsets columns by default, so R evaluates the condition it produces the following:
```{r}
mtcars$cyl > 4
```

A logical vector which exceeds the number of columns we have available, which leads us to the error above.

To filter for rows, you have to specify the columns in addition to the rows when filtering: 

```{r echo = TRUE, eval = FALSE}
df[row_index, col_index]
``` 

where a blank index signifies all rows or columns. Go ahead and fix the code and enter the correct expression below:

```{r filter, exercise = TRUE, exercise.lines = 1}

```

```{r filter-hint}
"The problematic code just needs one additional character for the fix."
```

```{r filter-check, include = FALSE}
grade_result(
  pass_if(~ identical(.result, mtcars[mtcars$cyl > 4, ]), "Remember to watch out for that comma!")
)
```

## Enter Tidy R

Up to this point we have been using functions and operations in "base" R which is what's included in R from the get-go. These include operators `[` and functions like `head`. Although these operators and functions are fine, they can be clunky to use and don't handle missing values and out-of-bound vectors properly selecting subsets of the dataframe.


- TODO: insert example of [ messing up with NA examples
- TODO: insert example of [ messing up with NA padding for out of bound ranges
- TODO: insert example of functions like head messing up with NA padding for out of bound ranges


The tidyverse is a collection of packages that is designed to handle operations in a safe and consistent manner, while providing intuitive functions:

- `filter`: choose observations (rows) by value(s)
- `arrange`: reorder rows
- `select`: choose variables (columns) by name
- `mutate`: derive new variables from existing ones
- `group_by`: define subsets of rows for further processing
- `summarize`: combine many values to create a single new value


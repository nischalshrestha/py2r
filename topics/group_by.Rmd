---
title: "mutate"
output: html_document
---

## `group_by`

So far we have been using the tidy verbs mostly in isolation for the purpose of learn how each one works. But, it's now time to explore performing operations on groups defined by variables. Using a handy verb called `group_by`, we'll cover how it changes interactions with other verbs as well as how it relates to Python.

```{r group_by-mtcars, echo=TRUE, exercise=TRUE, exercise.lines=3}
by_cyl <- mtcars %>% group_by(cyl)
by_cyl
```

```{r include=FALSE, context="data"}
by_cyl <- mtcars %>% group_by(cyl)
```


### Slice

When using `slice` on grouped data, we can retrieve the rows for each **cyl** group. Here we grab 3 rows for each:

```{r group_by-slice, echo=TRUE, exercise=TRUE, exercise.lines=3}
slice(by_cyl, 1:3)
```



### Select

```{r group_by-select, echo=TRUE, exercise=TRUE, exercise.lines=3}
by_cyl %>% select(group_cols())
```


### Filter

```{r group_by-filter, echo=TRUE, exercise=TRUE, exercise.lines=3}
# for each cyl, give me row of the max disp
by_cyl %>% filter(disp == max(disp))
```

### Arrange

**GOTCHA!** Grouped arrange ignores groups:

```{r group_by-arrange-nogroup, echo=TRUE, exercise=TRUE, exercise.lines=3}
by_cyl %>% arrange(desc(disp))
```

unless you specifically ask:

```{r group_by-arrange-group, echo=TRUE, exercise=TRUE, exercise.lines=3}
by_cyl %>% arrange(desc(wt), .by_group = TRUE)
```

### Mutate

```{r group_by-mutate-simple, echo=TRUE, exercise=TRUE, exercise.lines=3}
by_cyl %>% mutate(rank = min_rank(desc(mpg)))
```

Remember how we can use `mutate` to overwrite columns? Let's try doing that for our grouping variable **mpg** by executing the following.

```{r group_by-mutate-bad, echo=TRUE, exercise=TRUE, exercise.lines=3}
by_cyl %>% mutate(gdf, cyl = cyl * 100)
```

**GOTCHA!** When you group variables with `group_by`, you can't overwrite the grouping variables using `mutate`! You should've seen this error:

```
Error : Column `cyl` can't be modified because it's a grouping variable
```

Let's finish off this lesson by making it easier to examine the ranking of our **cyl** groups by doing a few things:

- First, let's use `mutate` again to do the ranking as before
- Then, move the **rank** column up to the front
- Finally `arrange` the rows by rank.

**Note**: You don't need to preserve row names and you can print the whole resulting dataframe.

```{r group_by-mutate-chained-exercise, echo=TRUE, exercise=TRUE, exercise.lines=6}

```

```{r group_by-mutate-chained-exercise-hint-1}
"Use a chain of piped calls using %>%"
```

```{r group_by-mutate-chained-exercise-hint-2}
"Don't forget about that gotcha on `arrange`!"
```

```{r group_by-mutate-chained-exercise-check}
grade_result(
  pass_if(~ identical(
    .,
    by_cyl %>% 
      mutate(rank = min_rank(desc(mpg))) %>% 
      select(rank, everything()) %>% 
      arrange(rank, .by_group = TRUE)
    )
  )
)
```

Once you've done that we can now clearly see the rows ordered according to the rank which is in turn based on **mpg** for each **cyl** groups 4, 6, and 8.

Now we're talking! For most data operations, we will be using groups of variables, so `group_by` will help us set up the right dataframe for performing statistics on the data.

#### If you want to learn more:

There are more advanced things you can do with `group_by`. For example, we didn't cover some of the variantes of `group_by` like . Check out the [docs](https://dplyr.tidyverse.org/reference/group_by.html) for detail.


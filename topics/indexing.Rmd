---
title: "Indexing"
output: html_document
---

## How do I index rows and columns?

Before you learn anything else about dataframe manipulations, you need to make it safely across the landmines waiting in the "indexing syntax" field before you. In this topic, we'll get you safely across and teach you the gotchas in R when moving from Python's row/column indexing.

### Index column

Let's try to index the column **mpg** column from mtcars.

<img src="../images/python_logo.png" class="language-icon">

You are used to indexing a column using either `[` or dot notation:

```{python echo=TRUE, eval=FALSE}
mtcars['mpg'].head()
```
```{python echo=TRUE, eval=FALSE}
mtcars['mpg']
```

```{python py-column-indexing}
print(mtcars['mpg'])
```

<img src="../images/r_logo.png" class="language-icon">

You can use the `[` as well. Try it out now by referencing the **mpg** column:

```{r column, exercise = TRUE, exercise.lines = 3}

```

```{r column-hint}
mtcars[col_name]
```

```{r column-check}
grade_result(
  pass_if(~ identical(.result, mtcars['mpg']), "Easy enough!"),
  fail_if(~ identical(.result, mtcars$mpg), "Using $ is fine but doesn't return a dataframe as explained in the next exercise.")
)
```

Using the `.` notation to reference a column does not work in R. Try executing `mtcars.mpg`

```{r wrong-reference, exercise = TRUE, exercise.lines = 2, echo=TRUE}

```

Since `.` can be included in a variable name, R thinks you are trying to reference a variable. The `.` cannot be used to reference a column as you would expect coming from Python.

Instead use `$`:
```{r column-indexing-2,  exercise = TRUE, exercise.lines = 3}

```

```{r column-indexing-2-check, include = FALSE}
grade_result(
  pass_if(~ identical(.result, mtcars$mpg), "Use $ when you need to reference a column.")
)
```

### Index a single element

Suppose we want to reference the fifth element of the **mpg** column.

<img src="../images/python_logo.png" class="language-icon">

In Python, you can use `[` on the dataframe to reference the **mpg** column then `[` again to access the fifth item:

```{python echo = TRUE, eval = FALSE}
mtcars['mpg'][4]
``` 

```{python py-single}
print(mtcars['mpg'][4])
```

**Note** how Python is 0-indexed.

<img src="../images/r_logo.png" class="language-icon">

We instead use `$` to reference **mpg**, then use `[` like Python for accessing the element. Try it out!

```{r single, exercise = TRUE, exercise.lines = 3}

```

```{r single-hint}
"Remember that we start counting from 1 in R."
```

```{r single-check, include = FALSE}
grade_result(
  pass_if(~ identical(.result, mtcars$mpg[5]), "Pretty easy right?")
)
```

You may wonder why we didn't use the `[` syntax instead. Using `[` returns a dataframe, so accessing the fifth element will throw an error because you have only one column **mpg** returned. See for yourself!

```{r single-check-wrong, exercise = TRUE, exercise.lines = 3, exercise.eval = TRUE}

```

### Indexing multiple columns

What if we wanted to select **mpg**, **cyl** and **hp** columns?

<!-- TODO: -->
<!-- - Gotcha: [[ only selects a single col unlike Python. -->

<img src="../images/python_logo.png" class="language-icon">

In Python, one could either use `[[` or the `.loc`:

```{python echo=TRUE, eval=FALSE}
mtcars[['mpg', 'cyl', 'hp']]
```
```{python echo=TRUE, eval=FALSE}
mtcars.loc[:, ['mpg', 'cyl', 'hp']]
```

```{python}
mtcars[['mpg', 'cyl', 'hp']]
```

<img src="../images/r_logo.png" class="language-icon">

However in R, the `[[` does not work for multiple columns. Go ahead and try it out:

```{r columns-index-bad, exercise = TRUE, exercise.lines = 3}

```

You should've seen a `subscript out of bounds` error. This is because dataframes in R are lists of columns and `[[` is used to reference a column label. So the inner `[` used as a list in Python does not work.

Instead, replace the inner `[` with `c()` which creates a list out of elements:

```{r columns-indexing,  exercise = TRUE, exercise.lines = 3}

```

```{r columns-indexing-check, include = FALSE}
grade_result(
  pass_if(~ identical(.result, mtcars[c('mpg', 'cyl', 'hp')]))
)
```

### Indexing rows

<!-- TODO: -->
<!-- - Gotcha: drop=FALSE is required to not drop dimensionality -->

What about indexing rows? Let's select the first two rows of mtcars.

<img src="../images/python_logo.png" class="language-icon">

In Python, one could just use the `[` or the `.iloc`:

```{python echo=TRUE, eval=FALSE}
mtcars[0:2]
```
```{python echo=TRUE, eval=FALSE}
mtcars.iloc[0:2]
```

```{python}
print(mtcars[0:2])
```

<img src="../images/r_logo.png" class="language-icon">

In R, we count from 1 but you need to be more careful when using `[` to index rows. Execute the following:

```{r row-index-bad, exercise=TRUE, exercise.lines=3, eval=TRUE}
mtcars[1:2]
```

Oops! R will select columns by default using `[` so the first two columns were selected instead of the rows. To fix this, we can use the `data[row_index, col_index]` form instead, where the left side of the comma is the row index and the right side the column index. 

To fix our example, we just add a comma after `1:2` and leave the `col_index` side empty to select all columns:

```{r rows-indexing, exercise=TRUE, exercise.lines=3}

```

```{r rows-indexing-hint-1}
"Remember to add the comma for indexing rows!"
```

```{r rows-indexing-hint-2}
mtcars[row_index, ]
```

```{r rows-indexing-check, include = FALSE}
# print(~ identical(.result, mtcars$mpg[5]))
grade_result(
  pass_if(~ identical(.result, mtcars[1:2, ]))
)
```

### Indexing rows and columns

Indexing both the rows and columns is much more simple for both Python and R if we follow the `data[row_index, col_index]` form for both.

Let's select the first 3 rows of the **mpg** and **cyl** columns of mtcars.

<img src="../images/python_logo.png" class="language-icon">

For Python, one can either use either the `[[` or `.iloc`:

```{python echo=TRUE, eval=FALSE}
mtcars[['mpg','cyl']][0:3]
mtcars.iloc[0:3, 0:2]
```

Or using the `.loc` which is rather tedious as one has to mention the row names:

```{python echo=TRUE, eval=FALSE}
mtcars.loc['Mazda RX4':'Datsun 710', ['mpg','cyl']]
```


```{python}
print(mtcars[['mpg','cyl']][0:3])
```

<img src="../images/r_logo.png" class="language-icon">

In R, we can use the `[` syntax then refer to columns as either number indices or column labels using the `data[row_indices, col_indices]` form. 

Give it a try:

```{r rows-columns-indexing, exercise=TRUE, exercise.lines=3}

```

```{r rows-columns-indexing-hint-1}
"You can use c() to specify column labels (e.g. 'col1', 'col2' etc.) or indices (e.g. 0, 1 etc.)"
```

```{r rows-columns-indexing-hint-2}
mtcars[row_index, c(columns)]
```

```{r rows-columns-indexing-check, include = FALSE}
# print(~ identical(.result, mtcars$mpg[5]))
grade_result(
  pass_if(~ identical(.result, mtcars[1:3, c('mpg', 'cyl')]), "You're getting the hang of this! :)")
)
```

You made it across the field! Now, on to bigger things.

<!--     - indexing: -->
<!--         - title: "How do I index rows and columns?" -->
<!--         - subtopic:  -->
<!--           - title: "Index column(s)" -->
<!--           - source:  -->
<!--             - "mtcars['mpg']" -->
<!--             - "mtcars.mpg" -->
<!--           - target: -->
<!--             - "mtcars['mpg']" -->
<!--             - "mtcars$mpg" -->
<!--             - "mtcars[['mpg', 'cyl]]" -->
<!--         - subtopic: -->
<!--           - title: "Index row(s)" -->
<!--           - source:  -->
<!--             - "mtcars[0:1]" -->
<!--           - target: -->
<!--             - "mtcars[0:1]" -->
<!--             - "mtcars[1:2]" -->




